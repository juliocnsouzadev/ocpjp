{"name":"Ocpjp","tagline":"Codes from OCPJP preparation","body":"### Preparação para exame:\r\n# Oracle Certified Professional 7 Programmer \r\n## 1Z0-805\r\n\r\n# Java Class Design\r\n\r\n## Objetivos:\r\n\r\nUsar modificadores de acesso: private, protected e public\r\nSobrescrever métodos\r\nSobrecarregar métodos\r\nSobrecarregar construtores\r\nUsar o operador intance of e casting\r\nUsar invocação virtual de métodos\r\nSobrescrever métodos da classe Object e melhorar suas funcionalidades em sua classe\r\nUsar declarações de import e package\r\n\r\n## Resumo\r\n\r\n### Fundamentos de POO\r\n\r\n• Encapsulamento: Combinar dados e funções em uma única unidade\r\n\r\n• Abstração: Esconder detalhes de baixo nível e expor somente os detalhes relevantes e essenciais para os usuários\r\n\r\n• Herança: Criar relacionamentos hirarquicos entre as classes\r\n\r\n• Polimorfismo: Intepretar a mesma chamada de métodos com diferentes significados dependendo do contexto\r\nFundamentos de Classe\r\n\r\n• Uma classe é um template e um objeto é uma instancia de uma classe\r\n\r\n• Um construtor não tem um tipo de retorno\r\n\r\n• Você não pode acessar métodos privados de uma classe base em uma subclasse\r\n\r\n• Você pode acessar métodos protegidos em uma subclasse ou em classe do mesmo pacote.\r\n\r\n• Você também pode acessar um método com modificar default se este estiver no mesmo pacote\r\n\r\n• Você pode acessar métodos públicos de uma classe de qualquer classe\r\n\r\n### Sobrecarga\r\n\r\n• Você pode ter contrutores sobrecarregados. Você pode chamar um construtor de uma mesma classe em outro contrutor usando a palavra-chave this\r\n\r\n• Sobrecarregar método: é criar métodos com o mesmo nome mas com parametros de tipos ou quantidades diferentes\r\n\r\n• Resolução de sobrecarga é o processo em que o compilador procura um método apropriado para os parametros passados nos métodos sobrecarregados disponíveis\r\nHerança\r\n\r\n• Herança é também chamada de relacionamento “é um”\r\n\r\n• Chamar um método baseado em tipo de objeto dinamicamente é chamado de polimorfismo em tempo de execução\r\n\r\n• Ao sobrescrever, o nome de um método, o número de argumentos, tipo de argumentos e tipo de retorno devem ser exatamente os mesmos\r\n\r\n• Com retornos com co-variantes, você prove uma subclasse do tipo retornado em um método sobrescrito\r\n\r\n• Você pode usar a palavra chave super para chamar métodos da classe base\r\n\r\n• Sobrecarga é uma exemplo de polimorfismo estático, enquanto que sobrescrita é um exemplo de polimorfismo dinamico\r\n\r\n• Você não precisa de fazer uma cast explícito para supertipos.\r\n\r\n• Você precisa de fazer uma cast explícito para subclasses. Como isso pode falhar user o operador instance of para garatir a validade do cast\r\n\r\n### Pacotes Java\r\n\r\n• Um pacote é um escopo de construção para categorizar suas classes e prover gerenciamento de nome espaço\r\n\r\n\r\n# Design de Classes Avançado Java\r\n## Objetivos:\r\n\r\n* Identificar como e quando usar classes abstratas\r\n* Construir classes abstratas e subclasses\r\n* Usar palavras chaves static e final\r\n* Criar classes aninhadas\r\n* Usar Enumerações\r\n\r\n## Resumo\r\n\r\n### Abstract Classes\r\n\r\n• Uma abstração fornece funcinalidades sem mostrar detalhes da implementação.\r\n• Você não pode criar intancias de uma classe abstrata.\r\n• Classes abstratas permitem polimorfismo em tempo de execução e polimofirmos em tempo de execução diminui o acoplamento entre as classes.\r\n\r\n### Usando “final” Keyword\r\n\r\n• Uma classe final não pode ser herdada.\r\n• Um método final não pode ser sobrescrito.\r\n• Todos os métodos de uma classe final, são implicitamente final.\r\n• Uma variável final pode ser designada apenas uma vez.\r\n\r\n### Usando “static” Keyword\r\n\r\n• Existem dois tipos de variáveis membro: variáveis de class e variáveis de instancia. Todas variáveis que necessitam de uma instancia de uma classe para serem acessadas são conhecidas como variáveis de instancia. Todas variáveis que são compartilhadas por todas intancias e associadas a uma classe e não a um objeto são referenciadas com variáveis de class (usam static em sua declaração)\r\n• Todos membros estáticos não necessitam de uma instancia para serem acessados, pode ser acessados pelo no nome da classe.\r\n• Um membro estático pode acessar ou chamar apenas outros membros estáticos sem uma instancia.\r\n\r\n### Sabores de Nested Classes\r\n\r\n• Java suporta 4 tipos de classes aninhadas: static nested classes, inner classes, local inner\r\nclasses, and anonymous inner classes.\r\n• Static nested classes podem ter static members, enquanto que outros tipos de classes aninhadaas não podem.\r\n• Static nested classes e inner classes podem acessar membros da outer class (mesmo que privados). Contudo, static nested classes podem acessar somente static members da outer class.\r\n• Local classes (tanto local inner classes quanto anonymous inner classes) podem acessar qualquer variável do escopo em que foram declaradas (metodos, contrutores ou blocos).\r\n• Enum são uma forma segura de restringir a entrada de dados de usuários.\r\n• You cannot use new with enums, even inside the enum definition.\r\n• Enum classes são default final classes.\r\n• Todas enum classes são implicitamente derivadas de java.lang.Enum.\r\n\r\n# Princípios POO\r\n## Objetivos:\r\n\r\n• escrever código que declare, implemente ou estenda interfaces\r\n• escolher entre o uso de herança de classes ou implementar interfaces\r\n• desenvolver código que implemente relacionamentos é-um e tem-um\r\n• aplicar princípios de composição\r\n• desenvolver código implementando os Design Patters: Siglenton, Factory, Abstract Factory e DAO\r\n\r\n## Resumo\r\n\r\n### Interfaces\r\n\r\n• É um contrato que define um protocolo do que deve ser feito, mas não como.\r\n• Não pode ser instanciada, mas pode herdar outras interfaces.\r\n• Todos os métodos declarados em uma interface são implicitamente considerados abstratos.\r\n• Uma classe Abstrata e uma interfaces possuem conceitos similares. Contudo cada uma deve ser usada corretamente baseado no contexto.\r\n\r\n### Object Composition\r\n\r\n• Herança determina relacinamento ‘é-um’, interface determina ‘é-como-um’, e composição determina ‘tem-um’.\r\n• Favoreça composição ao invés da herança sempre que possível.\r\n• Programe para uma interface e não para implementação.\r\n\r\n### Design Patterns\r\n\r\n• Observer é o padrão de projeto que diminui o acoplamento entre o objeto e seus obeservadores.\r\n• Singleton é o padrão de projeto que assegura que apenas uma intância de um objeto será criada.\r\n• Garantir que um singleton seja mesmo um singleton, especialmente em um ambiente multi-thread, não pe uma tarefa trivial.\r\n• Factory é o padrão de projeto que provê instâncias sob demanda.\r\n• Abstract Factory é o padrão de projeto que deve ser usado quando existe uma família de objetos a ser criado.\r\n\r\nPadrões de Projeto são soluções reutilizáveis para problemas recorrentes. O padrão DAO basicamente separa a lógica do negócio da lógica de persistência.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}