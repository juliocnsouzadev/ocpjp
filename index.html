<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Ocpjp : Codes from OCPJP preparation">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Ocpjp</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/juliocnsouzadev/ocpjp">View on GitHub</a>

          <h1 id="project_title">Ocpjp</h1>
          <h2 id="project_tagline">Codes from OCPJP preparation</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/juliocnsouzadev/ocpjp/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/juliocnsouzadev/ocpjp/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>
<a id="preparação-para-exame" class="anchor" href="#prepara%C3%A7%C3%A3o-para-exame" aria-hidden="true"><span class="octicon octicon-link"></span></a>Preparação para exame:</h3>

<h1>
<a id="oracle-certified-professional-7-programmer" class="anchor" href="#oracle-certified-professional-7-programmer" aria-hidden="true"><span class="octicon octicon-link"></span></a>Oracle Certified Professional 7 Programmer</h1>

<h2>
<a id="1z0-805" class="anchor" href="#1z0-805" aria-hidden="true"><span class="octicon octicon-link"></span></a>1Z0-805</h2>

<h1>
<a id="java-class-design" class="anchor" href="#java-class-design" aria-hidden="true"><span class="octicon octicon-link"></span></a>Java Class Design</h1>

<h2>
<a id="objetivos" class="anchor" href="#objetivos" aria-hidden="true"><span class="octicon octicon-link"></span></a>Objetivos:</h2>

<p>Usar modificadores de acesso: private, protected e public
Sobrescrever métodos
Sobrecarregar métodos
Sobrecarregar construtores
Usar o operador intance of e casting
Usar invocação virtual de métodos
Sobrescrever métodos da classe Object e melhorar suas funcionalidades em sua classe
Usar declarações de import e package</p>

<h2>
<a id="resumo" class="anchor" href="#resumo" aria-hidden="true"><span class="octicon octicon-link"></span></a>Resumo</h2>

<h3>
<a id="fundamentos-de-poo" class="anchor" href="#fundamentos-de-poo" aria-hidden="true"><span class="octicon octicon-link"></span></a>Fundamentos de POO</h3>

<p>• Encapsulamento: Combinar dados e funções em uma única unidade</p>

<p>• Abstração: Esconder detalhes de baixo nível e expor somente os detalhes relevantes e essenciais para os usuários</p>

<p>• Herança: Criar relacionamentos hirarquicos entre as classes</p>

<p>• Polimorfismo: Intepretar a mesma chamada de métodos com diferentes significados dependendo do contexto
Fundamentos de Classe</p>

<p>• Uma classe é um template e um objeto é uma instancia de uma classe</p>

<p>• Um construtor não tem um tipo de retorno</p>

<p>• Você não pode acessar métodos privados de uma classe base em uma subclasse</p>

<p>• Você pode acessar métodos protegidos em uma subclasse ou em classe do mesmo pacote.</p>

<p>• Você também pode acessar um método com modificar default se este estiver no mesmo pacote</p>

<p>• Você pode acessar métodos públicos de uma classe de qualquer classe</p>

<h3>
<a id="sobrecarga" class="anchor" href="#sobrecarga" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sobrecarga</h3>

<p>• Você pode ter contrutores sobrecarregados. Você pode chamar um construtor de uma mesma classe em outro contrutor usando a palavra-chave this</p>

<p>• Sobrecarregar método: é criar métodos com o mesmo nome mas com parametros de tipos ou quantidades diferentes</p>

<p>• Resolução de sobrecarga é o processo em que o compilador procura um método apropriado para os parametros passados nos métodos sobrecarregados disponíveis
Herança</p>

<p>• Herança é também chamada de relacionamento “é um”</p>

<p>• Chamar um método baseado em tipo de objeto dinamicamente é chamado de polimorfismo em tempo de execução</p>

<p>• Ao sobrescrever, o nome de um método, o número de argumentos, tipo de argumentos e tipo de retorno devem ser exatamente os mesmos</p>

<p>• Com retornos com co-variantes, você prove uma subclasse do tipo retornado em um método sobrescrito</p>

<p>• Você pode usar a palavra chave super para chamar métodos da classe base</p>

<p>• Sobrecarga é uma exemplo de polimorfismo estático, enquanto que sobrescrita é um exemplo de polimorfismo dinamico</p>

<p>• Você não precisa de fazer uma cast explícito para supertipos.</p>

<p>• Você precisa de fazer uma cast explícito para subclasses. Como isso pode falhar user o operador instance of para garatir a validade do cast</p>

<h3>
<a id="pacotes-java" class="anchor" href="#pacotes-java" aria-hidden="true"><span class="octicon octicon-link"></span></a>Pacotes Java</h3>

<p>• Um pacote é um escopo de construção para categorizar suas classes e prover gerenciamento de nome espaço</p>

<h1>
<a id="design-de-classes-avançado-java" class="anchor" href="#design-de-classes-avan%C3%A7ado-java" aria-hidden="true"><span class="octicon octicon-link"></span></a>Design de Classes Avançado Java</h1>

<h2>
<a id="objetivos-1" class="anchor" href="#objetivos-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Objetivos:</h2>

<ul>
<li>Identificar como e quando usar classes abstratas</li>
<li>Construir classes abstratas e subclasses</li>
<li>Usar palavras chaves static e final</li>
<li>Criar classes aninhadas</li>
<li>Usar Enumerações</li>
</ul>

<h2>
<a id="resumo-1" class="anchor" href="#resumo-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Resumo</h2>

<h3>
<a id="abstract-classes" class="anchor" href="#abstract-classes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Abstract Classes</h3>

<p>• Uma abstração fornece funcinalidades sem mostrar detalhes da implementação.
• Você não pode criar intancias de uma classe abstrata.
• Classes abstratas permitem polimorfismo em tempo de execução e polimofirmos em tempo de execução diminui o acoplamento entre as classes.</p>

<h3>
<a id="usando-final-keyword" class="anchor" href="#usando-final-keyword" aria-hidden="true"><span class="octicon octicon-link"></span></a>Usando “final” Keyword</h3>

<p>• Uma classe final não pode ser herdada.
• Um método final não pode ser sobrescrito.
• Todos os métodos de uma classe final, são implicitamente final.
• Uma variável final pode ser designada apenas uma vez.</p>

<h3>
<a id="usando-static-keyword" class="anchor" href="#usando-static-keyword" aria-hidden="true"><span class="octicon octicon-link"></span></a>Usando “static” Keyword</h3>

<p>• Existem dois tipos de variáveis membro: variáveis de class e variáveis de instancia. Todas variáveis que necessitam de uma instancia de uma classe para serem acessadas são conhecidas como variáveis de instancia. Todas variáveis que são compartilhadas por todas intancias e associadas a uma classe e não a um objeto são referenciadas com variáveis de class (usam static em sua declaração)
• Todos membros estáticos não necessitam de uma instancia para serem acessados, pode ser acessados pelo no nome da classe.
• Um membro estático pode acessar ou chamar apenas outros membros estáticos sem uma instancia.</p>

<h3>
<a id="sabores-de-nested-classes" class="anchor" href="#sabores-de-nested-classes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sabores de Nested Classes</h3>

<p>• Java suporta 4 tipos de classes aninhadas: static nested classes, inner classes, local inner
classes, and anonymous inner classes.
• Static nested classes podem ter static members, enquanto que outros tipos de classes aninhadaas não podem.
• Static nested classes e inner classes podem acessar membros da outer class (mesmo que privados). Contudo, static nested classes podem acessar somente static members da outer class.
• Local classes (tanto local inner classes quanto anonymous inner classes) podem acessar qualquer variável do escopo em que foram declaradas (metodos, contrutores ou blocos).
• Enum são uma forma segura de restringir a entrada de dados de usuários.
• You cannot use new with enums, even inside the enum definition.
• Enum classes são default final classes.
• Todas enum classes são implicitamente derivadas de java.lang.Enum.</p>

<h1>
<a id="princípios-poo" class="anchor" href="#princ%C3%ADpios-poo" aria-hidden="true"><span class="octicon octicon-link"></span></a>Princípios POO</h1>

<h2>
<a id="objetivos-2" class="anchor" href="#objetivos-2" aria-hidden="true"><span class="octicon octicon-link"></span></a>Objetivos:</h2>

<p>• escrever código que declare, implemente ou estenda interfaces
• escolher entre o uso de herança de classes ou implementar interfaces
• desenvolver código que implemente relacionamentos é-um e tem-um
• aplicar princípios de composição
• desenvolver código implementando os Design Patters: Siglenton, Factory, Abstract Factory e DAO</p>

<h2>
<a id="resumo-2" class="anchor" href="#resumo-2" aria-hidden="true"><span class="octicon octicon-link"></span></a>Resumo</h2>

<h3>
<a id="interfaces" class="anchor" href="#interfaces" aria-hidden="true"><span class="octicon octicon-link"></span></a>Interfaces</h3>

<p>• É um contrato que define um protocolo do que deve ser feito, mas não como.
• Não pode ser instanciada, mas pode herdar outras interfaces.
• Todos os métodos declarados em uma interface são implicitamente considerados abstratos.
• Uma classe Abstrata e uma interfaces possuem conceitos similares. Contudo cada uma deve ser usada corretamente baseado no contexto.</p>

<h3>
<a id="object-composition" class="anchor" href="#object-composition" aria-hidden="true"><span class="octicon octicon-link"></span></a>Object Composition</h3>

<p>• Herança determina relacinamento ‘é-um’, interface determina ‘é-como-um’, e composição determina ‘tem-um’.
• Favoreça composição ao invés da herança sempre que possível.
• Programe para uma interface e não para implementação.</p>

<h3>
<a id="design-patterns" class="anchor" href="#design-patterns" aria-hidden="true"><span class="octicon octicon-link"></span></a>Design Patterns</h3>

<p>• Observer é o padrão de projeto que diminui o acoplamento entre o objeto e seus obeservadores.
• Singleton é o padrão de projeto que assegura que apenas uma intância de um objeto será criada.
• Garantir que um singleton seja mesmo um singleton, especialmente em um ambiente multi-thread, não pe uma tarefa trivial.
• Factory é o padrão de projeto que provê instâncias sob demanda.
• Abstract Factory é o padrão de projeto que deve ser usado quando existe uma família de objetos a ser criado.</p>

<p>Padrões de Projeto são soluções reutilizáveis para problemas recorrentes. O padrão DAO basicamente separa a lógica do negócio da lógica de persistência.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Ocpjp maintained by <a href="https://github.com/juliocnsouzadev">juliocnsouzadev</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
